# -*- coding: utf-8 -*-
"""Pipeline

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yQnXeEWNWAzaaLQEyTRIR4UUZHOa4Jbt
"""

import numpy as np
import scipy as sp
import matplotlib.pyplot as plt
import pandas as pd
import pywt 
import tsfel 
from scipy.stats import gaussian_kde
from scipy.signal import freqz
from scipy.signal import butter


"""Default sampling frequency for accelerometer (WITMOTION) varies with time

Attempting to sample at 100 Hz
"""

#utils

        
def load_data(path, names=None, skip=1):
  return (pd.read_csv(path))

def getAccX(df):
  return df["AccX(g)"]

def getAccY(df):
  return df["AccY(g)"]

def getAccZ(df):
  return df["AccZ(g)"]

def getAsX(df):
  return df["AsX(°/s)"]

def getAsY(df):
  return df["AsY(°/s)"]

def getAsZ(df):
  return df["AsZ(°/s)"]

def getAngleX(df):
  return df["AngleX(°)"]

def getAngleY(df):
  return df["AngleY(°)"]

def getAngleZ(df):
  return df["AngleZ(°)"]

def mag(df):
  return(np.sqrt(df["Acceleration X(g)"] **2  + df["Acceleration Y(g)"] **2  + df["Acceleration Z(g)"] ** 2))

#euclidean norm minus 1
 
def enmo(x):
  return mag(x) - 1

def crop_sig(x, y):
  x_len = len(x)
  y_len = len(y)
  if x_len > y_len:
    return [x[0:y_len], y] #crop to y
  else:
    return [x, y[0:x_len]] #crop to x

## -- used if data is imported as strings --
def filter_str(val):
  return(isinstance(val, str))

def remove_str(df):
  return(df[~df.applymap(filter_str)])

#pass two original WITMOTION dataframes for normal and BK
#recieve plot of jerk (measure of dynamicity or un-smoothness) for both healthy vs BK, along with values relating to jerk
def jerk_metrics(normal, BK):
  normal = enmo(normal)
  BK = enmo(BK)

  sos = butter(4, [0.25, 3.5], btype='bandpass', fs=20, output='sos')

  def jerk(data):
    data2 = sp.signal.sosfilt(sos, data)
    jerk = pd.Series(np.gradient(data2), data.index, name='jerk')
    return jerk

  def msj(jerk):
    msj = 0
    for i in jerk:
      msj += np.square(i)
    msj/len(jerk)
    return msj

  def maxval(jerk):
    max = 0
    for i in jerk:
      if abs(i) > max:
        max = i
    return max

  def scaledmsj(jerk):
    return msj(jerk)/maxval(jerk)

  data = {
      'normal': [msj(jerk(normal)), maxval(jerk(normal)), scaledmsj(jerk(normal))],
      'BK': [msj(jerk(BK)), maxval(jerk(BK)), scaledmsj(jerk(BK))]
  }
  plt.plot(jerk(normal))
  plt.title("Jerk for Normal Movement")
  plt.xlabel("Jerk")
  plt.ylabel("Time")
  plt.legend()
  plt.show()

  plt.plot(jerk(BK))
  plt.title("Jerk for BK Movement")
  plt.xlabel("Jerk")
  plt.ylabel("Time")
  plt.legend()
  plt.show()
  print(pd.DataFrame(data, index=['msj', 'maxval', 'scaledmsj']))

#pass two original WITMOTION dataframes for normal and BK
#recieve plots of window means, ranges, and stddevs for healthy vs BK, along with various window metrics in a datatable
def window_properties(normal, BK, window_size):
  normal = enmo(normal)
  BK = enmo(BK)

  #crop so they're the same size
  cropped = crop_sig(normal, BK)
  normal = cropped[0]
  BK = cropped[1]

  def moving_win(x, ws):
    lo = 0
    hi = ws

    # declare arrays
    avgs = []
    idx = []
    ranges = []
    stds = []

    while hi < len(x):
      avgs.append(np.mean(x[lo:hi])) #mean acceleration from that window
      idx.append((lo + hi) // 2)
      ranges.append(np.max(x[lo:hi]) - np.min(x[lo:hi])) #range for that window
      stds.append(np.std(x[lo:hi])) #standard deviation for that window
      lo = hi
      hi += ws
    return [np.array(avgs), np.array(idx), np.array(ranges), np.array(stds)]

  #sums up all mean accelerations from each window to find a representative "total acceleration"
  def tot_acc(arr):
    return(np.sum(arr))
  def avg_acc(arr):
    return(np.mean(arr))

  normal_prop = moving_win(normal, window_size)
  BK_prop = moving_win(BK, window_size)

  data = {
      'normal': [avg_acc(normal), tot_acc(normal), np.std(normal_prop[0]), np.mean(normal_prop[2]), np.mean(normal_prop[3]), np.std(normal_prop[3])],
      'BK': [avg_acc(BK), tot_acc(BK), np.std(BK_prop[0]), np.mean(BK_prop[2]), np.mean(BK_prop[3]), np.std(BK_prop[3])]
  }

  plt.plot(normal_prop[0], label='normal')
  plt.plot(BK_prop[0], label='BK')
  plt.title("Window Means Over Time")
  plt.xlabel("Window Number")
  plt.legend()
  plt.show()

  plt.plot(normal_prop[2], label='normal')
  plt.plot(BK_prop[2], label='BK')
  plt.title("Window Ranges Over Time")
  plt.xlabel("Window Number")
  plt.legend()
  plt.show()

  plt.plot(normal_prop[3], label='normal')
  plt.plot(BK_prop[3], label='BK')
  plt.title("Window StdDevs Over Time")
  plt.xlabel("Window Number")
  plt.legend()
  plt.show()

  print(pd.DataFrame(data, index=["Average Acceleration", 'Total_Acc', 'Standard Deviation of Window Means', 'Mean of Window Ranges', 'Mean of Window StdDevs', 'Variance in Window StdDevs']))

#input is two original WITMOTION dataframes for normal and BK
#produces histogram distributions for each axis for healthy vs BK, and then a KD probability distribution approximation to find most "probable" acceleration
def Histogram(normal, BK):
  plt.hist(BK["Acceleration X(g)"], bins = 30, color = 'blue', label = 'Simulated BK', alpha = 0.4)
  plt.hist(normal["Acceleration X(g)"], bins = 30, color = 'orange', label = 'normal', alpha = 0.4)
  plt.title('Acceleration in X-axis Direction - Histogram')
  plt.xlabel('Acceleration')
  plt.ylabel('Frequency')
  plt.legend()
  plt.show()

  plt.hist(BK["Acceleration Y(g)"], bins = 30, color = 'blue', label = 'Simulated BK', alpha = 0.4)
  plt.hist(normal["Acceleration Y(g)"], bins = 30, color = 'orange', label = 'normal', alpha = 0.4)
  plt.title('Acceleration in Y-axis Direction - Histogram')
  plt.xlabel('Acceleration')
  plt.ylabel('Frequency')
  plt.legend()
  plt.show()

  plt.hist(BK["Acceleration Z(g)"], bins = 30, color = 'blue', label = 'Simulated BK', alpha = 0.4)
  plt.hist(normal["Acceleration Z(g)"], bins = 30, color = 'orange', label = 'normal', alpha = 0.4)
  plt.title('Acceleration in Z-axis Direction - Histogram')
  plt.xlabel('Acceleration')
  plt.ylabel('Frequency')
  plt.legend()
  plt.show()

  """
  plt.hist(enmo(BK), bins = 30, color = 'blue', label = 'Simulated BK', alpha = 0.4)
  plt.hist(enmo(normal), bins = 30, color = 'orange', label = 'normal', alpha = 0.4)
  plt.title('Acceleration Magnitude (minus gravity) - Histogram')
  plt.xlabel('Acceleration')
  plt.ylabel('Frequency')
  plt.legend()
  plt.show()
  """

  def plot_prob_dist(a, b):
    N = crop_sig(a, b)
    a = N[0]
    b = N[1]

    kde = gaussian_kde(a, bw_method='scott')  # or use bw_method='silverman'
    x_kde = np.linspace(min(a), max(a), 1000)
    kde_values = kde(x_kde)

    max1 = 0
    max_index = 0
    for i in x_kde:
      if kde(i) > max1:
        max_index = i
        max1 = kde(i)

    kde2 = gaussian_kde(b, bw_method='scott')  # or use bw_method='silverman'
    x_kde2 = np.linspace(min(b), max(b), 1000)
    kde_values2 = kde2(x_kde2)

    max2 = 0
    max_index2 = 0
    for i in x_kde2:
      if kde2(i) > max2:
        max_index2 = i
        max2 = kde2(i)

    x_min = min(min(a), min(b))
    x_max = max(max(a), max(b))
    z = np.linspace(x_min - 5, x_max + 5, 1000)

    p = np.clip(kde(z), 1e-10, None)
    q = np.clip(kde2(z), 1e-10, None)

    # Compute KL Divergence from KDE1 to KDE2
    kl_divergence = np.sum(p * np.log(p / q) * np.diff(z, prepend=z[0]))

    return [x_kde, kde_values, x_kde2, kde_values2, kl_divergence, max_index, max_index2]

  x_normkde, x_normvals, x_BKkde, x_BKvals, x_div, x_Normpa, x_BKpa = plot_prob_dist(normal["Acceleration X(g)"], BK["Acceleration X(g)"])
  plt.plot(x_normkde, x_normvals, label = "normal", color = "orange")
  plt.plot(x_BKkde, x_BKvals, label = "BK", color = "blue")
  plt.title('KD Plot for Acceleration in X direction')
  plt.xlabel('Acceleration')
  plt.ylabel('Frequency')
  plt.legend()
  plt.show()
  print("Divergence for x is:", x_div)
  print(pd.DataFrame(data = {
      'Most frequent acceleration': [x_Normpa, x_BKpa]
  }, index = ["Normal", "BK"]))

  y_normkde, y_normvals, y_BKkde, y_BKvals, y_div, y_Normpa, y_BKpa = plot_prob_dist(normal["Acceleration Y(g)"], BK["Acceleration Y(g)"])
  plt.plot(y_normkde, y_normvals, label = "normal", color = "orange")
  plt.plot(y_BKkde, y_BKvals, label = "BK", color = "blue")
  plt.title('KD Plot for Acceleration in Y direction')
  plt.xlabel('Acceleration')
  plt.ylabel('Frequency')
  plt.legend()
  plt.show()
  print("Divergence for y is: ", y_div )
  print(pd.DataFrame(data = {
      'Most frequent acceleration': [y_Normpa, y_BKpa]
  }, index = ["Normal", "BK"]))


  z_normkde, z_normvals, z_BKkde, z_BKvals, z_div, z_Normpa, z_BKpa = plot_prob_dist(normal["Acceleration Z(g)"], BK["Acceleration Z(g)"])
  plt.plot(z_normkde, z_normvals, label = "normal", color = "orange")
  plt.plot(z_BKkde, z_BKvals, label = "BK", color = "blue")
  plt.title('KD Plot for Acceleration in Z direction')
  plt.xlabel('Acceleration')
  plt.ylabel('Frequency')
  plt.legend()
  plt.show()
  print("Divergence for z is: ", z_div )
  print(pd.DataFrame(data = {
      'Most frequent acceleration': [z_Normpa, z_BKpa]
  }, index = ["Normal", "BK"]))

"""TEST FOR HEALTHY VS BK DATA"""

from google.colab import drive
drive.mount('/content/drive')
normal = norm_AS = load_data('/content/drive/MyDrive/DT20/Data (internal)/7-6 Data Recordings - AS, NO, CZ/Normal Brushing/AS_normal.csv')

BK = load_data('/content/drive/MyDrive/DT20/Data (internal)/7-6 Data Recordings - AS, NO, CZ/High BK/AS_brady_high.csv')

window_properties(normal, BK, 25)

jerk_metrics(normal, BK)

Histogram(normal, BK)